{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "liquidball",
  "type": "registry:ui",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "src/registry/default/ui/LiquidBall.tsx",
      "content": "\"use client\"\r\n\r\nimport { useState, useEffect, useRef } from \"react\"\r\n\r\nexport default function LiquidBall({ initialPercentage = 75, size = 100 }) {\r\n  const [percentage, setPercentage] = useState(initialPercentage)\r\n  const canvasRef = useRef<HTMLCanvasElement | null>(null)\r\n  const containerRef = useRef<HTMLDivElement>(null)\r\n  const [dimensions, setDimensions] = useState({ width: size, height: size })\r\n  const animationRef = useRef<number | null>(null)\r\n\r\n  useEffect(() => {\r\n    setPercentage(initialPercentage)\r\n  }, [initialPercentage])\r\n\r\n  useEffect(() => {\r\n    const handleResize = () => {\r\n      if (containerRef.current) {\r\n        const { width, height } = containerRef.current.getBoundingClientRect()\r\n        setDimensions({ width, height })\r\n      }\r\n    }\r\n\r\n    handleResize()\r\n    window.addEventListener('resize', handleResize)\r\n    \r\n    return () => {\r\n      window.removeEventListener('resize', handleResize)\r\n    }\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current\r\n    if (!canvas) return\r\n\r\n    const ctx = canvas.getContext(\"2d\", { alpha: true })\r\n    if (!ctx) return\r\n\r\n    const dpr = window.devicePixelRatio || 1\r\n\r\n    if (dimensions.width <= 0 || dimensions.height <= 0) return\r\n\r\n    const displayWidth = Math.round(dimensions.width)\r\n    const displayHeight = Math.round(dimensions.height)\r\n\r\n    canvas.style.width = `${displayWidth}px`\r\n    canvas.style.height = `${displayHeight}px`\r\n\r\n    canvas.width = Math.round(displayWidth * dpr)\r\n    canvas.height = Math.round(displayHeight * dpr)\r\n\r\n    ctx.scale(dpr, dpr)\r\n\r\n    ctx.imageSmoothingEnabled = true\r\n    ctx.imageSmoothingQuality = 'high'\r\n\r\n    let time = 0\r\n\r\n    const drawFlask = () => {\r\n      ctx.clearRect(0, 0, canvas.width as number, canvas.height as number)\r\n\r\n      const centerX = displayWidth / 2\r\n      const centerY = displayHeight / 2\r\n      \r\n      const radius = Math.max(1, Math.min(centerX, centerY) - 5)\r\n      \r\n      ctx.save()\r\n      \r\n      ctx.beginPath()\r\n      ctx.arc(centerX, centerY, radius + 0.5, 0, Math.PI * 2, false)\r\n      ctx.lineWidth = 1.5\r\n      ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)'\r\n      ctx.stroke()\r\n      \r\n      ctx.beginPath()\r\n      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, false)\r\n      ctx.closePath()\r\n      ctx.clip()\r\n\r\n      const maxWaterHeight = radius * 2 \r\n      const waterHeight = (percentage / 100) * maxWaterHeight\r\n      const baseWaterY = centerY + radius - waterHeight\r\n\r\n      const waveAmplitude = 3 + Math.sin(time * 0.3) * 1 \r\n      const waveFrequency = 0.08 + Math.sin(time * 0.2) * 0.01\r\n\r\n      const pointStep = 1 \r\n      const pointCount = Math.ceil((2 * radius) / pointStep) + 4\r\n      \r\n      const deepWaterGradient = ctx.createLinearGradient(0, baseWaterY - 10, 0, centerY + radius)\r\n      deepWaterGradient.addColorStop(0, \"rgba(10, 90, 80, 0.95)\")\r\n      deepWaterGradient.addColorStop(0.3, \"rgba(10, 90, 80, 1)\")\r\n      deepWaterGradient.addColorStop(0.7, \"rgba(10, 80, 70, 1)\")\r\n      deepWaterGradient.addColorStop(1, \"rgba(10, 70, 60, 1)\")\r\n\r\n      ctx.shadowColor = \"rgba(10, 90, 80, 0.3)\"\r\n      ctx.shadowBlur = 6\r\n\r\n      if (radius > 0) {\r\n        ctx.beginPath()\r\n        ctx.moveTo(centerX - radius - 2, baseWaterY + 10) \r\n\r\n        const deepWaveAmplitude = waveAmplitude * 1.2\r\n        const deepBackWaveOffset = 2 \r\n\r\n        for (let i = 0; i < pointCount; i++) {\r\n          const x = centerX - radius - 2 + i * pointStep\r\n\r\n          const wave1 = Math.sin((x + 10) * waveFrequency * 0.9 + time * 0.65) * deepWaveAmplitude * 1.1\r\n          const wave2 = Math.sin((x + 10) * waveFrequency * 1.5 + time * 1.15) * (deepWaveAmplitude * 0.6)\r\n          const wave3 = Math.sin((x + 10) * waveFrequency * 0.35 + time * 0.45) * (deepWaveAmplitude * 0.4)\r\n          const wave4 = Math.sin((x + 10) * waveFrequency * 2.3 + time * 0.25) * (deepWaveAmplitude * 0.3)\r\n\r\n          const variableOffset = Math.sin(x * 0.04 + time * 0.15) * 4 + 2\r\n          const waveHeight = wave1 + wave2 + wave3 + wave4\r\n\r\n          ctx.lineTo(x, baseWaterY + waveHeight + deepBackWaveOffset + variableOffset)\r\n        }\r\n\r\n        ctx.lineTo(centerX + radius + 2, centerY + radius)\r\n        ctx.lineTo(centerX - radius - 2, centerY + radius)\r\n        ctx.closePath()\r\n\r\n        ctx.fillStyle = deepWaterGradient\r\n        ctx.fill()\r\n\r\n        const backWaterGradient = ctx.createLinearGradient(0, baseWaterY - 10, 0, centerY + radius)\r\n        backWaterGradient.addColorStop(0, \"rgba(20, 120, 110, 0.95)\")\r\n        backWaterGradient.addColorStop(0.3, \"rgba(20, 120, 110, 1)\")\r\n        backWaterGradient.addColorStop(0.7, \"rgba(20, 110, 100, 1)\")\r\n        backWaterGradient.addColorStop(1, \"rgba(20, 100, 90, 1)\")\r\n\r\n        ctx.shadowColor = \"rgba(20, 120, 110, 0.3)\"\r\n        ctx.shadowBlur = 7\r\n\r\n        ctx.beginPath()\r\n        ctx.moveTo(centerX - radius - 2, baseWaterY + 10) \r\n        const backWaveAmplitude = waveAmplitude * 1.4\r\n        const baseBackWaveOffset = -1 \r\n\r\n        for (let i = 0; i < pointCount; i++) {\r\n          const x = centerX - radius - 2 + i * pointStep\r\n          const wave1 = Math.sin((x + 5) * waveFrequency + time * 0.75) * backWaveAmplitude * 1.1\r\n          const wave2 = Math.sin((x + 5) * waveFrequency * 1.7 + time * 1.25) * (backWaveAmplitude * 0.6)\r\n          const wave3 = Math.sin((x + 5) * waveFrequency * 0.4 + time * 0.55) * (backWaveAmplitude * 0.4)\r\n          const wave4 = Math.sin((x + 5) * waveFrequency * 2.5 + time * 0.35) * (backWaveAmplitude * 0.3)\r\n\r\n          const variableOffset = Math.sin(x * 0.05 + time * 0.2) * 3.5 - 1\r\n          const waveHeight = wave1 + wave2 + wave3 + wave4\r\n\r\n          ctx.lineTo(x, baseWaterY + waveHeight + baseBackWaveOffset + variableOffset)\r\n        }\r\n\r\n        ctx.lineTo(centerX + radius + 2, centerY + radius)\r\n        ctx.lineTo(centerX - radius - 2, centerY + radius)\r\n        ctx.closePath()\r\n        ctx.fillStyle = backWaterGradient\r\n        ctx.fill()\r\n\r\n        const waterGradient = ctx.createLinearGradient(0, baseWaterY - 10, 0, centerY + radius)\r\n        waterGradient.addColorStop(0, \"rgba(64, 190, 180, 0.9)\")\r\n        waterGradient.addColorStop(0.3, \"rgba(64, 190, 180, 0.95)\")\r\n        waterGradient.addColorStop(0.7, \"rgba(64, 180, 170, 1)\")\r\n        waterGradient.addColorStop(1, \"rgba(64, 170, 160, 1)\")\r\n\r\n        ctx.shadowColor = \"rgba(64, 190, 180, 0.3)\"\r\n        ctx.shadowBlur = 8\r\n\r\n        ctx.beginPath()\r\n        ctx.moveTo(centerX - radius - 2, baseWaterY + 10)\r\n        for (let i = 0; i < pointCount; i++) {\r\n          const x = centerX - radius - 2 + i * pointStep\r\n          const wave1 = Math.sin(x * waveFrequency + time) * waveAmplitude\r\n          const wave2 = Math.sin(x * waveFrequency * 2 + time * 1.3) * (waveAmplitude * 0.5)\r\n          const wave3 = Math.sin(x * waveFrequency * 0.5 + time * 0.7) * (waveAmplitude * 0.3)\r\n          const wave4 = Math.sin(x * waveFrequency * 3 + time * 0.5) * (waveAmplitude * 0.2)\r\n          const waveHeight = wave1 + wave2 + wave3 + wave4\r\n\r\n          ctx.lineTo(x, baseWaterY + waveHeight)\r\n        }\r\n        ctx.lineTo(centerX + radius + 2, centerY + radius)\r\n        ctx.lineTo(centerX - radius - 2, centerY + radius)\r\n        ctx.closePath()\r\n\r\n        ctx.fillStyle = waterGradient\r\n        ctx.fill()\r\n\r\n        ctx.shadowColor = \"transparent\"\r\n        ctx.shadowBlur = 0\r\n        if (percentage > 0) {\r\n          ctx.beginPath()\r\n\r\n          for (let i = 0; i < pointCount; i += 2) {\r\n            const x = centerX - radius - 2 + i * pointStep\r\n            if (x <= centerX + radius + 2) {\r\n              const wave1 = Math.sin(x * waveFrequency + time) * waveAmplitude\r\n              const wave2 = Math.sin(x * waveFrequency * 2 + time * 1.3) * (waveAmplitude * 0.5)\r\n              const wave3 = Math.sin(x * waveFrequency * 0.5 + time * 0.7) * (waveAmplitude * 0.3)\r\n              const wave4 = Math.sin(x * waveFrequency * 3 + time * 0.5) * (waveAmplitude * 0.2)\r\n              const waveHeight = wave1 + wave2 + wave3 + wave4\r\n\r\n              ctx.lineTo(x, baseWaterY + waveHeight - 0.5)\r\n            }\r\n          }\r\n          const highlightGradient = ctx.createLinearGradient(centerX - radius, baseWaterY, centerX + radius, baseWaterY)\r\n          highlightGradient.addColorStop(0, \"rgba(255, 255, 255, 0.1)\")\r\n          highlightGradient.addColorStop(0.5, \"rgba(255, 255, 255, 0.3)\")\r\n          highlightGradient.addColorStop(1, \"rgba(255, 255, 255, 0.1)\")\r\n\r\n          ctx.strokeStyle = highlightGradient\r\n          ctx.lineWidth = 1\r\n          ctx.stroke()\r\n          \r\n          ctx.beginPath()\r\n          const innerRadius = Math.max(0.5, radius - 1.5)\r\n          ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2, false)\r\n          ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'\r\n          ctx.lineWidth = 1\r\n          ctx.stroke()\r\n        }\r\n\r\n        const fontSize = Math.max(8, Math.min(16, radius / 2.5))\r\n        ctx.font = `bold ${fontSize}px Arial`\r\n        ctx.fillStyle = \"#fff\"\r\n        ctx.textAlign = \"center\"\r\n        ctx.textBaseline = \"middle\"\r\n        ctx.shadowColor = \"rgba(0, 0, 0, 0.4)\"\r\n        ctx.shadowBlur = 3\r\n        \r\n        ctx.fillText(`${Math.round(percentage)}%`, Math.round(centerX), Math.round(centerY))\r\n        ctx.shadowBlur = 0\r\n      }\r\n\r\n      ctx.restore()\r\n\r\n      time += 0.03\r\n\r\n      animationRef.current = requestAnimationFrame(drawFlask)\r\n    }\r\n\r\n    drawFlask()\r\n\r\n    return () => {\r\n      if (animationRef.current) {\r\n        cancelAnimationFrame(animationRef.current)\r\n      }\r\n    }\r\n  }, [percentage, dimensions]) \r\n\r\n  return (\r\n    <div \r\n      ref={containerRef}\r\n      className=\"relative\"\r\n      style={{ width: `${size}px`, height: `${size}px` }}\r\n    >\r\n      <canvas \r\n        ref={canvasRef} \r\n        className=\"w-full h-full rounded-full\" \r\n        style={{ \r\n          WebkitFontSmoothing: 'antialiased',\r\n          MozOsxFontSmoothing: 'grayscale'\r\n        }}\r\n      />\r\n    </div>\r\n  )\r\n}\r\n\r\n",
      "type": "registry:ui"
    }
  ]
}